# 瑞吉外卖项目




## 1、Day1业务开发-项目介绍以及登陆退出功能开发



### 1.1、软件开发的整体介绍

- 软件开发流程

  需求分析：产品原型、需求规格说明书

  设计：产品文档、UI界面设计、概要设计、详细设计、数据库设计

  编码：项目代码、单元测试

  测试：测试用例、测试报告

  上线运维：软件环境安装、配置
  
- 角色分工

  - 项目经理：对整个项目负责，任务分配、把控进度
  - 产品经理：进行需求调研，输出需求调研文档、产品原型等
  - UI设计师：根据产品原型输出界面效果图
  - 架构师：项目整体架构设计、技术选型等
  - 开发工程师：代码实现
  - 测试工程师：编写测试用例，输出测试报告
  - 运维工程师：软件环境搭建、项目上线

- 软件环境

  - 开发环境（development）：开发人员在开发阶段使用的环境，一般外部用户无法访问
  - 测试环境（testing）：专门给测试人员测试的环境，用于测试项目，一般外部用户无法访问
  - 生成环境（production）：即线上环境，正式提供对外服务的环境



### 1.2、项目介绍

- 项目介绍

  本项目专门为餐饮企业定制的一款软件产品，包括系统管理后台和移动端应用两部分。

  本项目共分为3期进行开发：

  第一期主要实现基本需求，其中移动端应用通过H5实现，用户可以通过手机浏览器访问

  第二期主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更方便

  第三期主要针对系统的优化升级，提高系统的访问性能

- 产品原型展示
- 技术选型
  - 用户层：H5,VUE.js,ElementUI,微信小程序
  - 网关层：Nginx（类似于Tomcat服务器，不过是部署静态页面资源）
  - 应用层：SpringBoot，SpringMVC，SpringSession，Spring，Swagger，lombok
  - 数据层：MySQL, MyBatis, MyBatisPlus, Redis(项目优化，做缓存)
  - 工具：git, maven,  junit
- 功能架构
  - 移动端前台(H5、微信小程序)：手机号登陆、微信登陆、地址管理、历史订单、菜品规格、购物车、下单、菜品浏览
  - 系统管理后台：分类管理、菜品管理、套餐管理、菜品口味管理、员工登陆、员工退出、员工管理、订单管理
- 角色
  - 后台系统管理员（相当于群主）：登陆后台管理系统，拥有后台系统中的所有操作权限（例如删除某个用户，删除菜品）
  - 后台系统普通员工（管理员）：登陆后台管理系统，对菜品、套餐、订单等进行管理
  - C端用户：登陆移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单



### 1.3、开发环境搭建

- 数据库环境搭建

  1. 创建项目对应的数据库

     reggie utf8mb4

     <img src="https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204151808925.png" style="zoom:50%;" />

  2. 导入表结构(图形化界面Navicat Premium)

  ```sql
  /*
  Navicat MySQL Data Transfer
  
  Source Server         : localhost
  Source Server Version : 50728
  Source Host           : localhost:3306
  Source Database       : reggie
  
  Target Server Type    : MYSQL
  Target Server Version : 50728
  File Encoding         : 65001
  
  Date: 2021-07-23 10:41:41
  */
  
  SET FOREIGN_KEY_CHECKS=0;
  
  -- ----------------------------
  -- Table structure for address_book
  -- ----------------------------
  DROP TABLE IF EXISTS `address_book`;
  CREATE TABLE `address_book` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `user_id` bigint(20) NOT NULL COMMENT '用户id',
    `consignee` varchar(50) COLLATE utf8_bin NOT NULL COMMENT '收货人',
    `sex` tinyint(4) NOT NULL COMMENT '性别 0 女 1 男',
    `phone` varchar(11) COLLATE utf8_bin NOT NULL COMMENT '手机号',
    `province_code` varchar(12) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '省级区划编号',
    `province_name` varchar(32) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '省级名称',
    `city_code` varchar(12) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '市级区划编号',
    `city_name` varchar(32) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '市级名称',
    `district_code` varchar(12) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '区级区划编号',
    `district_name` varchar(32) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '区级名称',
    `detail` varchar(200) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '详细地址',
    `label` varchar(100) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '标签',
    `is_default` tinyint(1) NOT NULL DEFAULT '0' COMMENT '默认 0 否 1是',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    `is_deleted` int(11) NOT NULL DEFAULT '0' COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='地址管理';
  
  -- ----------------------------
  -- Records of address_book
  -- ----------------------------
  INSERT INTO `address_book` VALUES ('1417414526093082626', '1417012167126876162', '小明', '1', '13812345678', null, null, null, null, null, null, '昌平区金燕龙办公楼', '公司', '1', '2021-07-20 17:22:12', '2021-07-20 17:26:33', '1417012167126876162', '1417012167126876162', '0');
  INSERT INTO `address_book` VALUES ('1417414926166769666', '1417012167126876162', '小李', '1', '13512345678', null, null, null, null, null, null, '测试', '家', '0', '2021-07-20 17:23:47', '2021-07-20 17:23:47', '1417012167126876162', '1417012167126876162', '0');
  
  -- ----------------------------
  -- Table structure for category
  -- ----------------------------
  DROP TABLE IF EXISTS `category`;
  CREATE TABLE `category` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `type` int(11) DEFAULT NULL COMMENT '类型   1 菜品分类 2 套餐分类',
    `name` varchar(64) COLLATE utf8_bin NOT NULL COMMENT '分类名称',
    `sort` int(11) NOT NULL DEFAULT '0' COMMENT '顺序',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `idx_category_name` (`name`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='菜品及套餐分类';
  
  -- ----------------------------
  -- Records of category
  -- ----------------------------
  INSERT INTO `category` VALUES ('1397844263642378242', '1', '湘菜', '1', '2021-05-27 09:16:58', '2021-07-15 20:25:23', '1', '1');
  INSERT INTO `category` VALUES ('1397844303408574465', '1', '川菜', '2', '2021-05-27 09:17:07', '2021-06-02 14:27:22', '1', '1');
  INSERT INTO `category` VALUES ('1397844391040167938', '1', '粤菜', '3', '2021-05-27 09:17:28', '2021-07-09 14:37:13', '1', '1');
  INSERT INTO `category` VALUES ('1413341197421846529', '1', '饮品', '11', '2021-07-09 11:36:15', '2021-07-09 14:39:15', '1', '1');
  INSERT INTO `category` VALUES ('1413342269393674242', '2', '商务套餐', '5', '2021-07-09 11:40:30', '2021-07-09 14:43:45', '1', '1');
  INSERT INTO `category` VALUES ('1413384954989060097', '1', '主食', '12', '2021-07-09 14:30:07', '2021-07-09 14:39:19', '1', '1');
  INSERT INTO `category` VALUES ('1413386191767674881', '2', '儿童套餐', '6', '2021-07-09 14:35:02', '2021-07-09 14:39:05', '1', '1');
  
  -- ----------------------------
  -- Table structure for dish
  -- ----------------------------
  DROP TABLE IF EXISTS `dish`;
  CREATE TABLE `dish` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `name` varchar(64) COLLATE utf8_bin NOT NULL COMMENT '菜品名称',
    `category_id` bigint(20) NOT NULL COMMENT '菜品分类id',
    `price` decimal(10,2) DEFAULT NULL COMMENT '菜品价格',
    `code` varchar(64) COLLATE utf8_bin NOT NULL COMMENT '商品码',
    `image` varchar(200) COLLATE utf8_bin NOT NULL COMMENT '图片',
    `description` varchar(400) COLLATE utf8_bin DEFAULT NULL COMMENT '描述信息',
    `status` int(11) NOT NULL DEFAULT '1' COMMENT '0 停售 1 起售',
    `sort` int(11) NOT NULL DEFAULT '0' COMMENT '顺序',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    `is_deleted` int(11) NOT NULL DEFAULT '0' COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `idx_dish_name` (`name`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='菜品管理';
  
  -- ----------------------------
  -- Records of dish
  -- ----------------------------
  INSERT INTO `dish` VALUES ('1397849739276890114', '辣子鸡', '1397844263642378242', '7800.00', '222222222', 'f966a38e-0780-40be-bb52-5699d13cb3d9.jpg', '来自鲜嫩美味的小鸡，值得一尝', '1', '0', '2021-05-27 09:38:43', '2021-05-27 09:38:43', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397850140982161409', '毛氏红烧肉', '1397844263642378242', '6800.00', '123412341234', '0a3b3288-3446-4420-bbff-f263d0c02d8e.jpg', '毛氏红烧肉毛氏红烧肉，确定不来一份？', '1', '0', '2021-05-27 09:40:19', '2021-05-27 09:40:19', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397850392090947585', '组庵鱼翅', '1397844263642378242', '4800.00', '123412341234', '740c79ce-af29-41b8-b78d-5f49c96e38c4.jpg', '组庵鱼翅，看图足以表明好吃程度', '1', '0', '2021-05-27 09:41:19', '2021-05-27 09:41:19', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397850851245600769', '霸王别姬', '1397844263642378242', '12800.00', '123412341234', '057dd338-e487-4bbc-a74c-0384c44a9ca3.jpg', '还有什么比霸王别姬更美味的呢？', '1', '0', '2021-05-27 09:43:08', '2021-05-27 09:43:08', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397851099502260226', '全家福', '1397844263642378242', '11800.00', '23412341234', 'a53a4e6a-3b83-4044-87f9-9d49b30a8fdc.jpg', '别光吃肉啦，来份全家福吧，让你长寿又美味', '1', '0', '2021-05-27 09:44:08', '2021-05-27 09:44:08', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397851370462687234', '邵阳猪血丸子', '1397844263642378242', '13800.00', '1246812345678', '2a50628e-7758-4c51-9fbb-d37c61cdacad.jpg', '看，美味不？来嘛来嘛，这才是最爱吖', '1', '0', '2021-05-27 09:45:12', '2021-05-27 09:45:12', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397851668262465537', '口味蛇', '1397844263642378242', '16800.00', '1234567812345678', '0f4bd884-dc9c-4cf9-b59e-7d5958fec3dd.jpg', '爬行界的扛把子，东兴-口味蛇，让你欲罢不能', '1', '0', '2021-05-27 09:46:23', '2021-05-27 09:46:23', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397852391150759938', '辣子鸡丁', '1397844303408574465', '8800.00', '2346812468', 'ef2b73f2-75d1-4d3a-beea-22da0e1421bd.jpg', '辣子鸡丁，辣子鸡丁，永远的魂', '1', '0', '2021-05-27 09:49:16', '2021-05-27 09:49:16', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397853183287013378', '麻辣兔头', '1397844303408574465', '19800.00', '123456787654321', '2a2e9d66-b41d-4645-87bd-95f2cfeed218.jpg', '麻辣兔头的详细制作，麻辣鲜香，色泽红润，回味悠长', '1', '0', '2021-05-27 09:52:24', '2021-05-27 09:52:24', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397853709101740034', '蒜泥白肉', '1397844303408574465', '9800.00', '1234321234321', 'd2f61d70-ac85-4529-9b74-6d9a2255c6d7.jpg', '多么的有食欲啊', '1', '0', '2021-05-27 09:54:30', '2021-05-27 09:54:30', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397853890262118402', '鱼香肉丝', '1397844303408574465', '3800.00', '1234212321234', '8dcfda14-5712-4d28-82f7-ae905b3c2308.jpg', '鱼香肉丝简直就是我们童年回忆的一道经典菜，上学的时候点个鱼香肉丝盖饭坐在宿舍床上看着肥皂剧，绝了！现在完美复刻一下上学的时候感觉', '1', '0', '2021-05-27 09:55:13', '2021-05-27 09:55:13', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397854652581064706', '麻辣水煮鱼', '1397844303408574465', '14800.00', '2345312·345321', '1fdbfbf3-1d86-4b29-a3fc-46345852f2f8.jpg', '鱼片是买的切好的鱼片，放几个虾，增加味道', '1', '0', '2021-05-27 09:58:15', '2021-05-27 09:58:15', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397854865672679425', '鱼香炒鸡蛋', '1397844303408574465', '2000.00', '23456431·23456', '0f252364-a561-4e8d-8065-9a6797a6b1d3.jpg', '鱼香菜也是川味的特色。里面没有鱼却鱼香味', '1', '0', '2021-05-27 09:59:06', '2021-05-27 09:59:06', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397860242057375745', '脆皮烧鹅', '1397844391040167938', '12800.00', '123456786543213456', 'e476f679-5c15-436b-87fa-8c4e9644bf33.jpeg', '“广东烤鸭美而香，却胜烧鹅说古冈（今新会），燕瘦环肥各佳妙，君休偏重便宜坊”，可见烧鹅与烧鸭在粤菜之中已早负盛名。作为广州最普遍和最受欢迎的烧烤肉食，以它的“色泽金红，皮脆肉嫩，味香可口”的特色，在省城各大街小巷的烧卤店随处可见。', '1', '0', '2021-05-27 10:20:27', '2021-05-27 10:20:27', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397860578738352129', '白切鸡', '1397844391040167938', '6600.00', '12345678654', '9ec6fc2d-50d2-422e-b954-de87dcd04198.jpeg', '白切鸡是一道色香味俱全的特色传统名肴，又叫白斩鸡，是粤菜系鸡肴中的一种，始于清代的民间。白切鸡通常选用细骨农家鸡与沙姜、蒜茸等食材，慢火煮浸白切鸡皮爽肉滑，清淡鲜美。著名的泮溪酒家白切鸡，曾获商业部优质产品金鼎奖。湛江白切鸡更是驰名粤港澳。粤菜厨坛中，鸡的菜式有200余款之多，而最为人常食不厌的正是白切鸡，深受食家青睐。', '1', '0', '2021-05-27 10:21:48', '2021-05-27 10:21:48', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397860792492666881', '烤乳猪', '1397844391040167938', '38800.00', '213456432123456', '2e96a7e3-affb-438e-b7c3-e1430df425c9.jpeg', '广式烧乳猪主料是小乳猪，辅料是蒜，调料是五香粉、芝麻酱、八角粉等，本菜品主要通过将食材放入炭火中烧烤而成。烤乳猪是广州最著名的特色菜，并且是“满汉全席”中的主打菜肴之一。烤乳猪也是许多年来广东人祭祖的祭品之一，是家家都少不了的应节之物，用乳猪祭完先人后，亲戚们再聚餐食用。', '1', '0', '2021-05-27 10:22:39', '2021-05-27 10:22:39', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397860963880316929', '脆皮乳鸽', '1397844391040167938', '10800.00', '1234563212345', '3fabb83a-1c09-4fd9-892b-4ef7457daafa.jpeg', '“脆皮乳鸽”是广东菜中的一道传统名菜，属于粤菜系，具有皮脆肉嫩、色泽红亮、鲜香味美的特点，常吃可使身体强健，清肺顺气。随着菜品制作工艺的不断发展，逐渐形成了熟炸法、生炸法和烤制法三种制作方法。无论那种制作方法，都是在鸽子经过一系列的加工，挂脆皮水后再加工而成，正宗的“脆皮乳鸽皮脆肉嫩、色泽红亮、鲜香味美、香气馥郁。这三种方法的制作过程都不算复杂，但想达到理想的效果并不容易。', '1', '0', '2021-05-27 10:23:19', '2021-05-27 10:23:19', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397861683434139649', '清蒸河鲜海鲜', '1397844391040167938', '38800.00', '1234567876543213456', '1405081e-f545-42e1-86a2-f7559ae2e276.jpeg', '新鲜的海鲜，清蒸是最好的处理方式。鲜，体会为什么叫海鲜。清蒸是广州最经典的烹饪手法，过去岭南地区由于峻山大岭阻隔，交通不便，经济发展起步慢，自家打的鱼放在锅里煮了就吃，没有太多的讲究，但却发现这清淡的煮法能使鱼的鲜甜跃然舌尖。', '1', '0', '2021-05-27 10:26:11', '2021-05-27 10:26:11', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397862198033297410', '老火靓汤', '1397844391040167938', '49800.00', '123456786532455', '583df4b7-a159-4cfc-9543-4f666120b25f.jpeg', '老火靓汤又称广府汤，是广府人传承数千年的食补养生秘方，慢火煲煮的中华老火靓汤，火候足，时间长，既取药补之效，又取入口之甘甜。 广府老火汤种类繁多，可以用各种汤料和烹调方法，烹制出各种不同口味、不同功效的汤来。', '1', '0', '2021-05-27 10:28:14', '2021-05-27 10:28:14', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1397862477831122945', '上汤焗龙虾', '1397844391040167938', '108800.00', '1234567865432', '5b8d2da3-3744-4bb3-acdc-329056b8259d.jpeg', '上汤焗龙虾是一道色香味俱全的传统名菜，属于粤菜系。此菜以龙虾为主料，配以高汤制成的一道海鲜美食。本品肉质洁白细嫩，味道鲜美，蛋白质含量高，脂肪含量低，营养丰富。是色香味俱全的传统名菜。', '1', '0', '2021-05-27 10:29:20', '2021-05-27 10:29:20', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1413342036832100354', '北冰洋', '1413341197421846529', '500.00', '', 'c99e0aab-3cb7-4eaa-80fd-f47d4ffea694.png', '', '1', '0', '2021-07-09 11:39:35', '2021-07-09 15:12:18', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1413384757047271425', '王老吉', '1413341197421846529', '500.00', '', '00874a5e-0df2-446b-8f69-a30eb7d88ee8.png', '', '1', '0', '2021-07-09 14:29:20', '2021-07-12 09:09:16', '1', '1', '0');
  INSERT INTO `dish` VALUES ('1413385247889891330', '米饭', '1413384954989060097', '200.00', '', 'ee04a05a-1230-46b6-8ad5-1a95b140fff3.png', '', '1', '0', '2021-07-09 14:31:17', '2021-07-11 16:35:26', '1', '1', '0');
  
  -- ----------------------------
  -- Table structure for dish_flavor
  -- ----------------------------
  DROP TABLE IF EXISTS `dish_flavor`;
  CREATE TABLE `dish_flavor` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `dish_id` bigint(20) NOT NULL COMMENT '菜品',
    `name` varchar(64) COLLATE utf8_bin NOT NULL COMMENT '口味名称',
    `value` varchar(500) COLLATE utf8_bin DEFAULT NULL COMMENT '口味数据list',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    `is_deleted` int(11) NOT NULL DEFAULT '0' COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='菜品口味关系表';
  
  -- ----------------------------
  -- Records of dish_flavor
  -- ----------------------------
  INSERT INTO `dish_flavor` VALUES ('1397849417888346113', '1397849417854791681', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:37:27', '2021-05-27 09:37:27', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397849739297861633', '1397849739276890114', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:38:43', '2021-05-27 09:38:43', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397849739323027458', '1397849739276890114', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:38:43', '2021-05-27 09:38:43', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397849936421761025', '1397849936404983809', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:39:30', '2021-05-27 09:39:30', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397849936438538241', '1397849936404983809', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:39:30', '2021-05-27 09:39:30', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850141015715841', '1397850140982161409', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:40:19', '2021-05-27 09:40:19', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850141040881665', '1397850140982161409', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:40:19', '2021-05-27 09:40:19', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850392120307713', '1397850392090947585', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:41:19', '2021-05-27 09:41:19', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850392137084929', '1397850392090947585', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:41:19', '2021-05-27 09:41:19', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850630734262274', '1397850630700707841', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:42:16', '2021-05-27 09:42:16', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850630755233794', '1397850630700707841', '辣度', '[\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:42:16', '2021-05-27 09:42:16', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850851274960898', '1397850851245600769', '忌口', '[\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:43:08', '2021-05-27 09:43:08', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397850851283349505', '1397850851245600769', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:43:08', '2021-05-27 09:43:08', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397851099523231745', '1397851099502260226', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:44:08', '2021-05-27 09:44:08', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397851099527426050', '1397851099502260226', '辣度', '[\"不辣\",\"微辣\",\"中辣\"]', '2021-05-27 09:44:08', '2021-05-27 09:44:08', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397851370483658754', '1397851370462687234', '温度', '[\"热饮\",\"常温\",\"去冰\",\"少冰\",\"多冰\"]', '2021-05-27 09:45:12', '2021-05-27 09:45:12', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397851370483658755', '1397851370462687234', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:45:12', '2021-05-27 09:45:12', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397851370483658756', '1397851370462687234', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:45:12', '2021-05-27 09:45:12', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397851668283437058', '1397851668262465537', '温度', '[\"热饮\",\"常温\",\"去冰\",\"少冰\",\"多冰\"]', '2021-05-27 09:46:23', '2021-05-27 09:46:23', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397852391180120065', '1397852391150759938', '忌口', '[\"不要葱\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:49:16', '2021-05-27 09:49:16', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397852391196897281', '1397852391150759938', '辣度', '[\"不辣\",\"微辣\",\"重辣\"]', '2021-05-27 09:49:16', '2021-05-27 09:49:16', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397853183307984898', '1397853183287013378', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:52:24', '2021-05-27 09:52:24', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397853423486414850', '1397853423461249026', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:53:22', '2021-05-27 09:53:22', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397853709126905857', '1397853709101740034', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:54:30', '2021-05-27 09:54:30', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397853890283089922', '1397853890262118402', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:55:13', '2021-05-27 09:55:13', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397854133632413697', '1397854133603053569', '温度', '[\"热饮\",\"常温\",\"去冰\",\"少冰\",\"多冰\"]', '2021-05-27 09:56:11', '2021-05-27 09:56:11', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397854652623007745', '1397854652581064706', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 09:58:15', '2021-05-27 09:58:15', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397854652635590658', '1397854652581064706', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:58:15', '2021-05-27 09:58:15', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397854865735593986', '1397854865672679425', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 09:59:06', '2021-05-27 09:59:06', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397855742303186946', '1397855742273826817', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:02:35', '2021-05-27 10:02:35', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397855906497605633', '1397855906468245506', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 10:03:14', '2021-05-27 10:03:14', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397856190573621250', '1397856190540066818', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:04:21', '2021-05-27 10:04:21', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397859056709316609', '1397859056684150785', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:15:45', '2021-05-27 10:15:45', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397859277837217794', '1397859277812051969', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:16:37', '2021-05-27 10:16:37', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397859487502086146', '1397859487476920321', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:17:27', '2021-05-27 10:17:27', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397859757061615618', '1397859757036449794', '甜味', '[\"无糖\",\"少糖\",\"半躺\",\"多糖\",\"全糖\"]', '2021-05-27 10:18:32', '2021-05-27 10:18:32', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397860242086735874', '1397860242057375745', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:20:27', '2021-05-27 10:20:27', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397860963918065665', '1397860963880316929', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:23:19', '2021-05-27 10:23:19', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397861135754506242', '1397861135733534722', '甜味', '[\"无糖\",\"少糖\",\"半躺\",\"多糖\",\"全糖\"]', '2021-05-27 10:24:00', '2021-05-27 10:24:00', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397861370035744769', '1397861370010578945', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-27 10:24:56', '2021-05-27 10:24:56', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397861683459305474', '1397861683434139649', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 10:26:11', '2021-05-27 10:26:11', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397861898467717121', '1397861898438356993', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 10:27:02', '2021-05-27 10:27:02', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397862198054268929', '1397862198033297410', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-27 10:28:14', '2021-05-27 10:28:14', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1397862477835317250', '1397862477831122945', '辣度', '[\"不辣\",\"微辣\",\"中辣\"]', '2021-05-27 10:29:20', '2021-05-27 10:29:20', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398089545865015297', '1398089545676271617', '温度', '[\"热饮\",\"常温\",\"去冰\",\"少冰\",\"多冰\"]', '2021-05-28 01:31:38', '2021-05-28 01:31:38', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398089782323097601', '1398089782285348866', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:32:34', '2021-05-28 01:32:34', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398090003262255106', '1398090003228700673', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-28 01:33:27', '2021-05-28 01:33:27', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398090264554811394', '1398090264517062657', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-28 01:34:29', '2021-05-28 01:34:29', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398090455399837698', '1398090455324340225', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:35:14', '2021-05-28 01:35:14', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398090685449023490', '1398090685419663362', '温度', '[\"热饮\",\"常温\",\"去冰\",\"少冰\",\"多冰\"]', '2021-05-28 01:36:09', '2021-05-28 01:36:09', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398090825358422017', '1398090825329061889', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-28 01:36:43', '2021-05-28 01:36:43', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398091007051476993', '1398091007017922561', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:37:26', '2021-05-28 01:37:26', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398091296164851713', '1398091296131297281', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:38:35', '2021-05-28 01:38:35', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398091546531246081', '1398091546480914433', '忌口', '[\"不要葱\",\"不要蒜\",\"不要香菜\",\"不要辣\"]', '2021-05-28 01:39:35', '2021-05-28 01:39:35', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398091729809747969', '1398091729788776450', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:40:18', '2021-05-28 01:40:18', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398091889499484161', '1398091889449152513', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:40:56', '2021-05-28 01:40:56', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398092095179763713', '1398092095142014978', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:41:45', '2021-05-28 01:41:45', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398092283877306370', '1398092283847946241', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:42:30', '2021-05-28 01:42:30', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398094018939236354', '1398094018893099009', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:49:24', '2021-05-28 01:49:24', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1398094391494094850', '1398094391456346113', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-05-28 01:50:53', '2021-05-28 01:50:53', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1399574026165727233', '1399305325713600514', '辣度', '[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]', '2021-06-01 03:50:25', '2021-06-01 03:50:25', '1399309715396669441', '1399309715396669441', '0');
  INSERT INTO `dish_flavor` VALUES ('1413389540592263169', '1413384757047271425', '温度', '[\"常温\",\"冷藏\"]', '2021-07-12 09:09:16', '2021-07-12 09:09:16', '1', '1', '0');
  INSERT INTO `dish_flavor` VALUES ('1413389684020682754', '1413342036832100354', '温度', '[\"常温\",\"冷藏\"]', '2021-07-09 15:12:18', '2021-07-09 15:12:18', '1', '1', '0');
  
  -- ----------------------------
  -- Table structure for employee
  -- ----------------------------
  DROP TABLE IF EXISTS `employee`;
  CREATE TABLE `employee` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `name` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '姓名',
    `username` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '用户名',
    `password` varchar(64) COLLATE utf8_bin NOT NULL COMMENT '密码',
    `phone` varchar(11) COLLATE utf8_bin NOT NULL COMMENT '手机号',
    `sex` varchar(2) COLLATE utf8_bin NOT NULL COMMENT '性别',
    `id_number` varchar(18) COLLATE utf8_bin NOT NULL COMMENT '身份证号',
    `status` int(11) NOT NULL DEFAULT '1' COMMENT '状态 0:禁用，1:正常',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `idx_username` (`username`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='员工信息';
  
  -- ----------------------------
  -- Records of employee
  -- ----------------------------
  INSERT INTO `employee` VALUES ('1', '管理员', 'admin', 'e10adc3949ba59abbe56e057f20f883e', '13812312312', '1', '110101199001010047', '1', '2021-05-06 17:20:07', '2021-05-10 02:24:09', '1', '1');
  
  -- ----------------------------
  -- Table structure for orders
  -- ----------------------------
  DROP TABLE IF EXISTS `orders`;
  CREATE TABLE `orders` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `number` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '订单号',
    `status` int(11) NOT NULL DEFAULT '1' COMMENT '订单状态 1待付款，2待派送，3已派送，4已完成，5已取消',
    `user_id` bigint(20) NOT NULL COMMENT '下单用户',
    `address_book_id` bigint(20) NOT NULL COMMENT '地址id',
    `order_time` datetime NOT NULL COMMENT '下单时间',
    `checkout_time` datetime NOT NULL COMMENT '结账时间',
    `pay_method` int(11) NOT NULL DEFAULT '1' COMMENT '支付方式 1微信,2支付宝',
    `amount` decimal(10,2) NOT NULL COMMENT '实收金额',
    `remark` varchar(100) COLLATE utf8_bin DEFAULT NULL COMMENT '备注',
    `phone` varchar(255) COLLATE utf8_bin DEFAULT NULL,
    `address` varchar(255) COLLATE utf8_bin DEFAULT NULL,
    `user_name` varchar(255) COLLATE utf8_bin DEFAULT NULL,
    `consignee` varchar(255) COLLATE utf8_bin DEFAULT NULL,
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='订单表';
  
  -- ----------------------------
  -- Records of orders
  -- ----------------------------
  
  -- ----------------------------
  -- Table structure for order_detail
  -- ----------------------------
  DROP TABLE IF EXISTS `order_detail`;
  CREATE TABLE `order_detail` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `name` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '名字',
    `image` varchar(100) COLLATE utf8_bin DEFAULT NULL COMMENT '图片',
    `order_id` bigint(20) NOT NULL COMMENT '订单id',
    `dish_id` bigint(20) DEFAULT NULL COMMENT '菜品id',
    `setmeal_id` bigint(20) DEFAULT NULL COMMENT '套餐id',
    `dish_flavor` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '口味',
    `number` int(11) NOT NULL DEFAULT '1' COMMENT '数量',
    `amount` decimal(10,2) NOT NULL COMMENT '金额',
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='订单明细表';
  
  -- ----------------------------
  -- Records of order_detail
  -- ----------------------------
  
  -- ----------------------------
  -- Table structure for setmeal
  -- ----------------------------
  DROP TABLE IF EXISTS `setmeal`;
  CREATE TABLE `setmeal` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `category_id` bigint(20) NOT NULL COMMENT '菜品分类id',
    `name` varchar(64) COLLATE utf8_bin NOT NULL COMMENT '套餐名称',
    `price` decimal(10,2) NOT NULL COMMENT '套餐价格',
    `status` int(11) DEFAULT NULL COMMENT '状态 0:停用 1:启用',
    `code` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT '编码',
    `description` varchar(512) COLLATE utf8_bin DEFAULT NULL COMMENT '描述信息',
    `image` varchar(255) COLLATE utf8_bin DEFAULT NULL COMMENT '图片',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    `is_deleted` int(11) NOT NULL DEFAULT '0' COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `idx_setmeal_name` (`name`)
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='套餐';
  
  -- ----------------------------
  -- Records of setmeal
  -- ----------------------------
  INSERT INTO `setmeal` VALUES ('1415580119015145474', '1413386191767674881', '儿童套餐A计划', '4000.00', '1', '', '', '61d20592-b37f-4d72-a864-07ad5bb8f3bb.jpg', '2021-07-15 15:52:55', '2021-07-15 15:52:55', '1415576781934608386', '1415576781934608386', '0');
  
  -- ----------------------------
  -- Table structure for setmeal_dish
  -- ----------------------------
  DROP TABLE IF EXISTS `setmeal_dish`;
  CREATE TABLE `setmeal_dish` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `setmeal_id` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '套餐id ',
    `dish_id` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '菜品id',
    `name` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT '菜品名称 （冗余字段）',
    `price` decimal(10,2) DEFAULT NULL COMMENT '菜品原价（冗余字段）',
    `copies` int(11) NOT NULL COMMENT '份数',
    `sort` int(11) NOT NULL DEFAULT '0' COMMENT '排序',
    `create_time` datetime NOT NULL COMMENT '创建时间',
    `update_time` datetime NOT NULL COMMENT '更新时间',
    `create_user` bigint(20) NOT NULL COMMENT '创建人',
    `update_user` bigint(20) NOT NULL COMMENT '修改人',
    `is_deleted` int(11) NOT NULL DEFAULT '0' COMMENT '是否删除',
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='套餐菜品关系';
  
  -- ----------------------------
  -- Records of setmeal_dish
  -- ----------------------------
  INSERT INTO `setmeal_dish` VALUES ('1415580119052894209', '1415580119015145474', '1397862198033297410', '老火靓汤', '49800.00', '1', '0', '2021-07-15 15:52:55', '2021-07-15 15:52:55', '1415576781934608386', '1415576781934608386', '0');
  INSERT INTO `setmeal_dish` VALUES ('1415580119061282817', '1415580119015145474', '1413342036832100354', '北冰洋', '500.00', '1', '0', '2021-07-15 15:52:55', '2021-07-15 15:52:55', '1415576781934608386', '1415576781934608386', '0');
  INSERT INTO `setmeal_dish` VALUES ('1415580119069671426', '1415580119015145474', '1413385247889891330', '米饭', '200.00', '1', '0', '2021-07-15 15:52:55', '2021-07-15 15:52:55', '1415576781934608386', '1415576781934608386', '0');
  
  -- ----------------------------
  -- Table structure for shopping_cart
  -- ----------------------------
  DROP TABLE IF EXISTS `shopping_cart`;
  CREATE TABLE `shopping_cart` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `name` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '名称',
    `image` varchar(100) COLLATE utf8_bin DEFAULT NULL COMMENT '图片',
    `user_id` bigint(20) NOT NULL COMMENT '主键',
    `dish_id` bigint(20) DEFAULT NULL COMMENT '菜品id',
    `setmeal_id` bigint(20) DEFAULT NULL COMMENT '套餐id',
    `dish_flavor` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '口味',
    `number` int(11) NOT NULL DEFAULT '1' COMMENT '数量',
    `amount` decimal(10,2) NOT NULL COMMENT '金额',
    `create_time` datetime DEFAULT NULL COMMENT '创建时间',
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='购物车';
  
  -- ----------------------------
  -- Records of shopping_cart
  -- ----------------------------
  
  -- ----------------------------
  -- Table structure for user
  -- ----------------------------
  DROP TABLE IF EXISTS `user`;
  CREATE TABLE `user` (
    `id` bigint(20) NOT NULL COMMENT '主键',
    `name` varchar(50) COLLATE utf8_bin DEFAULT NULL COMMENT '姓名',
    `phone` varchar(100) COLLATE utf8_bin NOT NULL COMMENT '手机号',
    `sex` varchar(2) COLLATE utf8_bin DEFAULT NULL COMMENT '性别',
    `id_number` varchar(18) COLLATE utf8_bin DEFAULT NULL COMMENT '身份证号',
    `avatar` varchar(500) COLLATE utf8_bin DEFAULT NULL COMMENT '头像',
    `status` int(11) DEFAULT '0' COMMENT '状态 0:禁用，1:正常',
    PRIMARY KEY (`id`) USING BTREE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='用户信息';
  
  ```

  3. 数据表

     <img src="https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204151809438.png" style="zoom:50%;" />
     
     | 序号 | 表名          | 说明             |
     | ---- | ------------- | ---------------- |
     | 1    | employee      | 员工表           |
     | 2    | category      | 菜品和套餐分类表 |
     | 3    | dish          | 菜品表           |
     | 4    | setmeal       | 套餐表           |
     | 5    | setmeal_dish  | 套餐菜品关系表   |
     | 6    | dish_flavor   | 菜品口味关系表   |
     | 7    | user          | 用户表（C端）    |
     | 8    | address_book  | 地址簿表         |
     | 9    | shopping_cart | 购物车表         |
     | 10   | orders        | 订单表           |
     | 11   | order_detail  | 订单明细表       |
     
     

- maven项目搭建

  1. pom.xml

     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <project xmlns="http://maven.apache.org/POM/4.0.0"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
         <modelVersion>4.0.0</modelVersion>
         <!--继承springboot的父工程文件-->
         <parent>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-parent</artifactId>
             <version>2.4.5</version>
             <relativePath/> <!-- lookup parent from repository -->
         </parent>
         <groupId>com.reggie</groupId>
         <artifactId>reggie_tack_out</artifactId>
         <version>1.0-SNAPSHOT</version>
     
         <properties>
             <!--指定jdk版本-->
             <java.version>1.8</java.version>
             <maven.compiler.source>8</maven.compiler.source>
             <maven.compiler.target>8</maven.compiler.target>
         </properties>
         <dependencies>
             <!--SpringBoot的启动依赖-->
             <dependency>
                 <groupId>org.springframework.boot</groupId>
                 <artifactId>spring-boot-starter</artifactId>
             </dependency>
             <!--SpringBoot的测试依赖-->
             <dependency>
                 <groupId>org.springframework.boot</groupId>
                 <artifactId>spring-boot-starter-test</artifactId>
                 <scope>test</scope>
             </dependency>
             <!--SpringBoot应用于web开发的依赖-->
             <dependency>
                 <groupId>org.springframework.boot</groupId>
                 <artifactId>spring-boot-starter-web</artifactId>
                 <scope>compile</scope>
             </dependency>
             <!--mybatisPlus的依赖-->
             <dependency>
                 <groupId>com.baomidou</groupId>
                 <artifactId>mybatis-plus-boot-starter</artifactId>
                 <version>3.4.2</version>
             </dependency>
             <!--lombok插件-->
             <dependency>
                 <groupId>org.projectlombok</groupId>
                 <artifactId>lombok</artifactId>
                 <version>1.18.20</version>
             </dependency>
             <!--fastjson插件，将对象快速转换为json对象-->
             <dependency>
                 <groupId>com.alibaba</groupId>
                 <artifactId>fastjson</artifactId>
                 <version>1.2.76</version>
             </dependency>
             <!--通用语言包-->
             <dependency>
                 <groupId>commons-lang</groupId>
                 <artifactId>commons-lang</artifactId>
                 <version>2.6</version>
             </dependency>
             <!--mysql驱动-->
             <dependency>
                 <groupId>mysql</groupId>
                 <artifactId>mysql-connector-java</artifactId>
                 <scope>runtime</scope>
             </dependency>
             <!--druid数据库连接池-->
             <dependency>
                 <groupId>com.alibaba</groupId>
                 <artifactId>druid-spring-boot-starter</artifactId>
                 <version>1.1.23</version>
             </dependency>
     
         </dependencies>
     
         <build>
             <plugins>
                 <plugin>
                     <groupId>org.springframework.boot</groupId>
                     <artifactId>spring-boot-maven-plugin</artifactId>
                     <version>2.4.5</version>
                 </plugin>
             </plugins>
         </build>
     
     
     </project>
     ```

  2. pplication.yml

     ```yaml
     server:
       port: 8080 #配置启动的端口号
     spring:
       application:
         name: reggie_take_out # 配置应用的名称，不配默认就是项目工程名称
       # 数据源的配置 druid
       datasource:
         druid:
           driver-class-name: com.mysql.cj.jdbc.Driver
           url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
           username: root
           password: 12345678
     # mp的配置
     mybatis-plus:
       configuration:
         #在映射实体或者属性时，将数据库中 表名 和 字段名 中的下划线去掉，按照驼峰命名法映射
         #address_book------>AddressBook
         #user_name------>userName
         map-underscore-to-camel-case: true
         # 配置mp的日志，并输出到控制台中
         log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
       global-config:
         db-config:
           # 配置id
           id-type: ASSIGN_ID
     ```

  3. 编写启动类

  4. 创建启动类com.reggie.ReggieApplication.java

     ```java
     package com.reggie;
     
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.boot.SpringApplication;
     import org.springframework.boot.autoconfigure.SpringBootApplication;
     
     @Slf4j//使用lombok提供的日志
     @SpringBootApplication
     public class ReggieApplication {
         public static void main(String[] args) {
             SpringApplication.run(ReggieApplication.class,args);
             //输出日志
             log.info("项目启动成功...");
         }
     }
     
     ```

     5. 导入静态页面

        把资料中的前台后台页面导入到resource中，因为SpringBoot默认的静态资源应该放在static或者template目录才能不用修改配置就可以访问到，不过我们通过修改配置来告诉SpringBoot我们的静态资源在backend和front目录中（配置SpringBoot配置类）

     6. 编写mvc静态资源映射的配置类

        ```java
        package com.reggie.config;
        
        import lombok.extern.slf4j.Slf4j;
        import org.springframework.context.annotation.Configuration;
        import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
        import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
        
        /**
         * mvc静态资源映射 配置类
         */
        
        @Slf4j
        @Configuration//说明这个是SpringBoot的配置类
        //让这个类继承WebMvcConfigurationSupport
        public class WebMvcConfig extends WebMvcConfigurationSupport {
            /**
             * 设置静态资源映射
             * 重写WebMvcConfigurationSupport中的addResourceHandlers方法
             * @param registry
             */
            @Override
            protected void addResourceHandlers(ResourceHandlerRegistry registry) {
                //调用registry的addResourceHandler添加资源处理器，
                //再调用addResourceLocations添加资源路径（classpath对应的是resource目录）
                    //后台
                log.info("开始进行静态资源映射");
                registry.addResourceHandler("/backend/**")
                        .addResourceLocations("classpath:/backend/");
                    //前台
                registry.addResourceHandler("/front/**")
                        .addResourceLocations("classpath:/front/");
            }
        }
        
        ```

     7. 成功访问页面http://localhost:8080/backend/index.html



### 1.4、登陆功能开发

- 需求分析

  访问后台登陆界面：http://localhost:8080/backend/page/login/login.html

  打开控制台登陆发现404提示消息，因为我们controller还没有对应的处理HTTP请求的路径

- 代码开发

  我们通过阅读前端的代码发现，我们后端需要给前端提供3个数据分别为：code（成功的标志：1：成功），date（响应的数据），msg（响应的信息），即**通用返回结果类R**

  1. 创建实体类Employee，和employee表进行映射

  ```java
  package com.reggie.entity;
  
  import com.baomidou.mybatisplus.annotation.FieldFill;
  import com.baomidou.mybatisplus.annotation.TableField;
  import lombok.Data;
  import java.io.Serializable;
  import java.time.LocalDateTime;
  
  /**
   * 员工实体类
   */
  @Data
  public class Employee implements Serializable {
  
      private static final long serialVersionUID = 1L;
  
      private Long id;
  
      private String username;
  
      private String name;
  
      private String password;
  
      private String phone;
  
      private String sex;
  
      //身份证号码，不过在数据库中的名称是id_number，
      // 但是我们在application.yml配置文件中开启了按照驼峰命名法映射，
      // 所以以后在配置yml的时候一定记得要开启这个配置
      private String idNumber;
  
      private Integer status;
  
      private LocalDateTime createTime;
  
      private LocalDateTime updateTime;
  
      @TableField(fill = FieldFill.INSERT)
      private Long createUser;
  
      @TableField(fill = FieldFill.INSERT_UPDATE)
      private Long updateUser;
  
  }
  
  ```

  2. 通用返回结果类R

     ```java
     package com.reggie.common;
     
     import lombok.Data;
     import java.util.HashMap;
     import java.util.Map;
     
     /**
      * 通用返回结果，服务端最终响应的数据都会封装成此对象
      * @param <T>
      */
     @Data
     public class R<T> {
     
         private Integer code; //编码：1成功，0和其它数字为失败
     
         private String msg; //错误信息
     
         private T data; //数据
     
         private Map map = new HashMap(); //动态数据（用的少）
     
         //我们在外就不用new这个R对象了，直接通过R.success(employee)调用方法，因为方法内部new了本身对象
         public static <T> R<T> success(T object) {
             R<T> r = new R<T>();
             r.data = object;
             r.code = 1;
             return r;
         }
     
         public static <T> R<T> error(String msg) {
             R r = new R();
             r.msg = msg;
             r.code = 0;
             return r;
         }
     
         public R<T> add(String key, Object value) {
             this.map.put(key, value);
             return this;
         }
     
     }
     
     ```
     
     
     
  2. 创建mapper.EmployeeMapper.java

     ```java
     package com.reggie.mapper;
     
     import com.baomidou.mybatisplus.core.mapper.BaseMapper;
     import com.reggie.entity.Employee;
     import org.apache.ibatis.annotations.Mapper;
     
     /**
      * 创建员工mapper接口，基于mybatisPlus简化开发，
      * 直接让接口继承 BaseMapper< T >，自动完成基本的数据库操作功能
      */
     @Mapper
     public interface EmployeeMapper extends BaseMapper<Employee> {
     }
     
     ```

  2. service.EmployeeService.java

     ```java
     package com.reggie.service;
     
     import com.baomidou.mybatisplus.extension.service.IService;
     import com.reggie.entity.Employee;
     
     public interface EmployeeService extends IService<Employee> {
     }
     
     ```
     
  5. service.impl.EmployeeServiceImpl.java

     ```java
     package com.reggie.service.impl;
     
     import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
     import com.reggie.entity.Employee;
     import com.reggie.mapper.EmployeeMapper;
     import com.reggie.service.EmployeeService;
     import org.springframework.stereotype.Service;
     
     @Service
     public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee>
                                      implements EmployeeService {
     
     }
     
     ```

  6. controller.EmployeeController

     ```java
     package com.reggie.controller;
     
     import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
     import com.reggie.common.R;
     import com.reggie.entity.Employee;
     import com.reggie.service.EmployeeService;
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.util.DigestUtils;
     import org.springframework.web.bind.annotation.PostMapping;
     import org.springframework.web.bind.annotation.RequestBody;
     import org.springframework.web.bind.annotation.RequestMapping;
     import org.springframework.web.bind.annotation.RestController;
     
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpSession;
     import java.util.Objects;
     
     @Slf4j
     @RestController
     @RequestMapping("/employee")
     public class EmployeeController {
     
         @Autowired
         private EmployeeService employeeService;
     
         /**
          * 员工登陆：
          * 参数一：登陆成功后，需要把Employee员工对象存入到session，表示登陆成功
          * 参数二：接收前端页面的登陆数据，post请求，请求数据为json类型的
          * 在登陆参数中添加一个@RequestBody注解,以根据请求的内容类型解析方法参数
          * 传的json中有一个key是username 还有一个是password,与Employee实体类中的属性命名必须一样
          * 否则无法封装成功
          * @param request
          * @param employee
          * @return
          */
         @PostMapping("/login")
         public R<Employee> login(HttpServletRequest request,
                                  @RequestBody Employee employee){
             /*
              * 处理逻辑：
              * 1.首先对用户输入的密码进行md5加密（因为数据库中的密码是md5加密后的）
              * 2.根据用户名查询数据库（没有用户，返回msg失败结果）
              * 3.比对密码是否一致
              * 4.查看员工状态是否禁用
              * 5.将员工id放入到session中，返回成功的结果
              */
     
             //1.密码进行md5加密：
             //  使用DigestUtils工具类中的md5DigestAsHex方法
             String password = employee.getPassword();
             password = DigestUtils.md5DigestAsHex(password.getBytes());
             //2.根据用户名查数据库
             LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
             //第一个参数是数据库中的数据，第二个参数是前端页面传入的数据
             queryWrapper.eq(Employee::getUsername,employee.getUsername());
             //调用employeeService的getOne方法，因为数据库中对用户名添加了一个唯一约束
             Employee emp = employeeService.getOne(queryWrapper);
             //3.如果没有查到则返回登陆失败结果
             if (Objects.isNull(emp)){
                 return R.error("登陆失败");
             }
             //4.比对密码
             if (!emp.getPassword().equals(password)){
                 return R.error("密码错误");
             }
             //5.查看员工状态
             if (emp.getStatus() == 0){
                 return R.error("该账户已禁用");
             }
             //6.登陆成功，将员工的id存入到Session中并返回登陆成功的结果
             HttpSession session = request.getSession();
             session.setAttribute("employee",emp.getId());
             return R.success(emp);
         }
     
     }
     
     
     ```

- 功能测试





### 1.5、后台退出系统功能开发

- 需求分析

  用户点击页面退出按钮，发送请求，请求地址为/employee/logout,请求方式为post

  我们只需要在Controller中创建对应的处理方法即可，具体的处理逻辑：

  1. 清理session中的用户id
  2. 返回结果

- 代码开发

  ```java
  		 /**
       * 员工退出
       * 1.清理session中保存的当前登陆员工的id
       * 2.返回结果（退出成功）
       * @param request
       * @return
       */
      @PostMapping("/logout")
      public R<String> logout(HttpServletRequest request){
          request.getSession().removeAttribute("employee");
          return R.success("退出成功！");
      }
  
  ```

  

- 功能测试



## 2、Day2业务开发-操作员工



### 2.1、完善登陆功能-过滤器

- 问题分析

  我们完成Day1的登陆功能，但是我们发现用户不登录直接访问首页也可以进入，

  我们希望用户必须完成登陆才能进入后台页面，当用户访问主页面我们让用户先去登陆

  那么，我们就可以通过使用过滤器或者拦截器，在过滤器或者拦截器中判断用户是否完成登陆，如果没有登陆就跳转到登陆页面

- 代码实现

  实现步骤：

  1. 创建自定义过滤器LoginCheckFilter

     ```java
     package com.reggie.filter;
     
     /**
      * 自定义过滤器：
      * 检查用户是否已经完成登陆
      */
     @Slf4j
     @WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")
     public class LoginCheckFilter implements Filter {
         @Override
         public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
             HttpServletRequest request = (HttpServletRequest) servletRequest;
             HttpServletResponse response = (HttpServletResponse) servletResponse;
             log.info("拦截到请求:{}",request.getRequestURI());
             filterChain.doFilter(request,response);
         }
     }
     
     ```

     

  2. 在启动类上加入注解@ServletComponentScan（开启组件扫描，这样才会扫描这个过滤器组件）

     ```java
     package com.reggie;
     
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.boot.SpringApplication;
     import org.springframework.boot.autoconfigure.SpringBootApplication;
     import org.springframework.boot.web.servlet.ServletComponentScan;
     
     @Slf4j//使用lombok提供的日志
     @ServletComponentScan//扫描WebFilter的一些注解
     @SpringBootApplication
     public class ReggieApplication {
         public static void main(String[] args) {
             SpringApplication.run(ReggieApplication.class,args);
             //输出日志
             log.info("项目启动成功...");
         }
     }
     
     ```

     测试：

     ```
     2022-04-13 18:24:23.118  INFO 86203 --- [           main] com.reggie.config.WebMvcConfig           : 开始进行静态资源映射
     2022-04-13 18:24:23.247  INFO 86203 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
     2022-04-13 18:24:23.252  INFO 86203 --- [           main] com.reggie.ReggieApplication             : Started ReggieApplication in 0.968 seconds (JVM running for 1.194)
     2022-04-13 18:24:23.253  INFO 86203 --- [           main] com.reggie.ReggieApplication             : 项目启动成功...
     2022-04-13 18:24:27.440  INFO 86203 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
     2022-04-13 18:24:27.440  INFO 86203 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
     2022-04-13 18:24:27.441  INFO 86203 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
     2022-04-13 18:24:27.442  INFO 86203 --- [nio-8080-exec-1] com.reggie.filter.LoginCheckFilter       : 拦截到请求:/backend/index.html
     2022-04-13 18:24:27.488  INFO 86203 --- [nio-8080-exec-2] com.reggie.filter.LoginCheckFilter       : 拦截到请求:/backend/js/request.js
     2022-04-13 18:24:27.554  INFO 86203 --- [nio-8080-exec-3] com.reggie.filter.LoginCheckFilter       : 拦截到请求:/employee/page
     2022-04-13 18:24:27.555  WARN 86203 --- [nio-8080-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /employee/page
     2022-04-13 18:25:21.305  INFO 86203 --- [nio-8080-exec-5] com.reggie.filter.LoginCheckFilter       : 拦截到请求:/backend/index.html
     2022-04-13 18:25:21.416  INFO 86203 --- [nio-8080-exec-6] com.reggie.filter.LoginCheckFilter       : 拦截到请求:/employee/page
     2022-04-13 18:25:21.417  WARN 86203 --- [nio-8080-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /employee/page
     2022-04-13 18:25:36.974  INFO 86203 --- [extShutdownHook] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closing ...
     2022-04-13 18:25:36.975  INFO 86203 --- [extShutdownHook] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed
     
     ```

     

  3. 完善过滤器的处理逻辑

     1. 获取本次请求的URI
     2. 判断本次请求是否需要处理
     3. 如果不需要处理，则直接放行
     4. 判断登陆状态，如果已登录，则直接放行
     5. 如果未登录则返回未登录结果

     ```java
     package com.reggie.filter;
     
     import com.alibaba.fastjson.JSON;
     import com.reggie.common.R;
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.util.AntPathMatcher;
     
     import javax.servlet.*;
     import javax.servlet.annotation.WebFilter;
     import javax.servlet.http.HttpServletRequest;
     import javax.servlet.http.HttpServletResponse;
     import java.io.IOException;
     
     /**
      * 自定义过滤器：
      * 检查用户是否已经完成登陆
      */
     @Slf4j
     @WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")
     public class LoginCheckFilter implements Filter {
         //路径匹配器，支持通配符写法
         public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();
         @Override
         public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
             HttpServletRequest request = (HttpServletRequest) servletRequest;
             HttpServletResponse response = (HttpServletResponse) servletResponse;
     
             //1. 获取本次请求的URI
             String requestURI = request.getRequestURI();
             log.info("拦截到请求:{}",requestURI);
                 //定义不需要处理的请求路径
             String[] urls = new String[]{
                     "/employee/login",
                     "/employee/logout",
                     "/backend/**",
                     "/front/**"
             };
             //2. 判断本次请求是否需要处理
             boolean check = check(urls, requestURI);
     
             //3. 如果不需要处理，则直接放行
             if (check){
                 log.info("本次请求{}不需要处理",requestURI);
                 filterChain.doFilter(request,response);
                 //后面代码不需要执行了，直接return让方法结束
                 return;
             }
             //4. 判断登陆状态，如果已登录，则直接放行
                 //从session中获取登陆存储的信息
             if (request.getSession().getAttribute("employee") != null) {
                 log.info("用户已登陆,用户的id为:{}",request.getSession().getAttribute("employee"));
                 filterChain.doFilter(request,response);
                 return;
             }
             //5. 如果未登录则返回未登录结果，通过输出流的方式，向客户端页面响应数据
             log.info("用户未登陆");
             response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
         }
     
         /**
          * 路径匹配，检查本次请求是否需要放行
          * @param urls
          * @param requestURI
          * @return
          */
         public boolean check(String[] urls,String requestURI){
             for (String url : urls) {
                 boolean match = PATH_MATCHER.match(url, requestURI);
                 if (match){
                     return true;
                 }
             }
             return false;
         }
     }
     
     ```

     

- 功能测试



### 2.2、新增员工

- 需求分析

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161245871.png)

  

- 数据模型

  username是员工的登陆账号，必须是唯一的

  <img src="https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161249497.png" style="zoom:50%;" />

- 代码开发

  首先通过前端页面发现点击保存的时候发送了一个POST/employee 的请求，所以我们需要进行这个请求处理的接口开发

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161253263.png)

  以及请求的参数（json）

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161256960.png)

  1. 页面发送ajax请求，将新增员工页面中输入的数据以json形式提交到服务端

  2. 服务端controller接收页面提交的数据并调用service将数据进行保存

     ```java
     /**
          * 新增员工
          * @param employee
          * @return
          */
         @PostMapping
         public R<String> save(@RequestBody Employee employee){
             log.info("新增员工，员工信息{}",employee.toString());
     
             return null;
         }
     ```

     进行一个测试：后端已经接收到数据

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161310978.png)

     

  3. service调用mapper操作数据库，保存数据

     ```java
     /**
          * 新增员工
          * @param employee
          * @return
          */
         @PostMapping
         public R<String> save(HttpServletRequest request,@RequestBody Employee employee){
             log.info("新增员工，员工信息{}",employee.toString());
             //id=null, username=zhangsan, name=张三, password=null,
             // phone=17358002861, sex=1, idNumber=111222333444555666,
             // status=null, createTime=null, updateTime=null,
             // createUser=null, updateUser=null
             //设置初始密码：123456，但是需要进行md5的加密处理
             //status不需要设置，因为数据库中设置了默认值 1 启用
             employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
     
             //设置创建和修改时间
             employee.setCreateTime(LocalDateTime.now());
             employee.setUpdateTime(LocalDateTime.now());
     
             //设置创建该用户的人
                 //获得当前登陆用户的id
             HttpSession session = request.getSession();
             Long empId = (Long) session.getAttribute("employee");
             employee.setCreateUser(empId);
             employee.setUpdateUser(empId);
     
             //调用IService 把数据保存到数据库
             employeeService.save(employee);
     
             return R.success("新增员工成功！");
         }
     ```

- 功能测试

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161329069.png)

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161329300.png)

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161330440.png)

  不过我们发现当我们添加的用户名一样的时候，会抛出异常，因为在数据库中username是不可重复的

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161342534.png)
  
  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161345818.png)
  
  
  
  所以我们需要解决这个问题



### 2.3、解决添加用户时候用户名重复异常

解决方案：

1. 在controller方法中加入try、catch进行异常捕获

   ```java
   				try {
               employeeService.save(employee);
           } catch (Exception e) {
               R.error("新增员工失败！");
           }
   ```

   但是这种处理方式不是很好，因为后续我们有很多这种需要异常处理的，所以建议使用第二种

2. 使用异常处理器进行全局异常捕获

   ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161347446.png)

   ```java
   package com.reggie.common;
   
   import lombok.extern.slf4j.Slf4j;
   import org.springframework.stereotype.Controller;
   import org.springframework.web.bind.annotation.ControllerAdvice;
   import org.springframework.web.bind.annotation.ExceptionHandler;
   import org.springframework.web.bind.annotation.ResponseBody;
   import org.springframework.web.bind.annotation.RestController;
   
   import java.sql.SQLIntegrityConstraintViolationException;
   
   /**
    * 全局异常处理器
    * 代理AOP
    */
   //不管哪个类上加了这个RestController或者Controller注解，都会被我们这个类处理
   @ControllerAdvice(annotations = {RestController.class, Controller.class})
   @ResponseBody//因为我们还要写一个方法，最终返回json数据的
   @Slf4j
   public class GlobalExceptionHandler {
   
       /**
        * 异常处理方法：
        * 一旦controller抛出这种SQLIntegrityConstraintViolationException异常
        * 就会被这个方法处理
        * @return
        */
       @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
       public R<String> exceptionHandler(SQLIntegrityConstraintViolationException exception){
           log.error(exception.getMessage());
           //Duplicate entry 'zhangsan' for key 'employee.idx_username'
           //首先判断异常信息中是否有Duplicate entry关键字信息，因为出现异常不一定都是双重输入重复异常
           if (exception.getMessage().contains("Duplicate entry")){
               //这个时候肯定是用户名重复了
               //我们提取出重复的用户名，使用空格分割
               String[] split = exception.getMessage().split(" ");
               String msg = split[2] + "已存在";
               //返回错误信息
               return R.error(msg);
   
           }
   
           return R.error("未知错误");
       }
   
   }
   
   ```

   再次测试添加zhangsan用户，控制台输出内容

   ```bash
   2022-04-16 14:00:01.259  INFO 36733 --- [nio-8080-exec-6] com.reggie.filter.LoginCheckFilter       : 拦截到请求:/employee
   2022-04-16 14:00:01.259  INFO 36733 --- [nio-8080-exec-6] com.reggie.filter.LoginCheckFilter       : 用户已登陆,用户的id为:1
   2022-04-16 14:00:01.260  INFO 36733 --- [nio-8080-exec-6] c.reggie.controller.EmployeeController   : 新增员工，员工信息Employee(id=null, username=zhangsan, name=张三, password=null, phone=13888888888, sex=1, idNumber=123123123123123123, status=null, createTime=null, updateTime=null, createUser=null, updateUser=null)
   Creating a new SqlSession
   SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6b2fc935] was not registered for synchronization because synchronization is not active
   JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6fd4be8] will not be managed by Spring
   ==>  Preparing: INSERT INTO employee ( id, username, name, password, phone, sex, id_number, create_time, update_time, create_user, update_user ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
   ==> Parameters: 1515208369936285697(Long), zhangsan(String), 张三(String), e10adc3949ba59abbe56e057f20f883e(String), 13888888888(String), 1(String), 123123123123123123(String), 2022-04-16T14:00:01.260(LocalDateTime), 2022-04-16T14:00:01.260(LocalDateTime), 1(Long), 1(Long)
   Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6b2fc935]
   2022-04-16 14:00:01.263 ERROR 36733 --- [nio-8080-exec-6] c.reggie.common.GlobalExceptionHandler   : Duplicate entry 'zhangsan' for key 'employee.idx_username'
   2022-04-16 14:00:49.050  INFO 36733 --- [extShutdownHook] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closing ...
   2022-04-16 14:00:49.052  INFO 36733 --- [extShutdownHook] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed
   
   ```




### 2.4、员工信息分页查询

- 需求分析

  系统中员工很多的时候，在一页中展示出来会很乱，不便于查看，所以一般的系统中都会有以分页的方式来展现数据列表

  ![image-20220416141253488](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161412622.png)

  

- 代码开发

  1. 页面发送ajax请求，将分页查询参数（page、pageSize、name）提交到服务端

  2. 服务端创建controller接收页面数据并调用service查询数据

     1. 创建MP配置类，通过拦截器方式插入分页插件

        ```java
        package com.reggie.config;
        
        import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
        import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        
        /**
         * 配置MP的分页插件
         */
        @Configuration
        public class MybatisPlusConfig {
        
            //通过拦截器的方式把分页插件加入进来
            @Bean
            public MybatisPlusInterceptor mybatisPlusInterceptor(){
                MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
                mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        
                return mybatisPlusInterceptor;
            }
        }
        
        ```

     2. 创建分页查询的接口

        ```java
        package com.reggie.config;
        
        import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
        import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        
        /**
         * 配置MP的分页插件
         */
        @Configuration
        public class MybatisPlusConfig {
        
            //通过拦截器的方式把分页插件加入进来
            @Bean
            public MybatisPlusInterceptor mybatisPlusInterceptor(){
                MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
                mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        
                return mybatisPlusInterceptor;
            }
        }
        
        ```

        

  3. service调用mapper操作数据，查询分页数据

  4. controller将查询到的分页数据响应给页面

     ```java
     		 /**
          * 员工信息的分页查询
          * @param page
          * @param pageSize
          * @param name
          * @return
          */
         @GetMapping("/page")
         public R<Page> page(int page,int pageSize,String name){
             log.info("page = {},pageSize = {},name = {}",page,pageSize,name);
             //分页构造器
             Page<Employee> pageInfo = new Page<>(page,pageSize);
     
             //条件构造器
             LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
             //添加过滤条件,使用like自带的判断条件，
             // 第一个参数：判断是否有内容，如果没有内容则不会执行like
             queryWrapper.like(StringUtils.hasText(name),Employee::getName,name);
             //添加排序条件
             queryWrapper.orderByDesc(Employee::getUpdateTime);
     
             //执行查询
             employeeService.page(pageInfo,queryWrapper);
     
             return R.success(pageInfo);
         }
     ```

     

  5. 页面接收到分页的数据通过elementUI的Table组件进行展示到页面上

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161500612.png)

- 功能测试



### 2.5、启用/禁用员工账号

- 需求分析

  在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登陆系统，启用后的员工可以正常登陆

  需要注意的是，只有管理员（admin用户）可以对其他用户进行启用或者禁用操作，所以普通用户登陆系统后，启用和禁用按钮不显示

- 代码开发

  1. 页面发送ajax请求，将参数（id，status）提交到服务端

     <img src="https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161523409.png" style="zoom:50%;" />

     <img src="https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161522262.png" style="zoom:50%;" />

  2. 服务端controller接收页面提交的数据并调用service更新数据

  3. service调用mapper操作数据库

     ```java
     		 /**
          * 根据id修改员工信息（基本信息以及status状态信息）
          * @param employee
          * @return
          */
         @PutMapping
         public R<String> update(HttpServletRequest request, @RequestBody Employee employee){
             log.info(employee.toString());//查看employee是否封装上了
             //在更新前设置一下更新人的信息
             employee.setUpdateTime(LocalDateTime.now());
             employee.setUpdateUser((Long) request.getSession().getAttribute("employee"));
     
             //进行更新
             employeeService.updateById(employee);
     
             return R.success("员工信息修改成功");
         }
     ```

     

- 功能测试

  我们访问页面点击禁用后发现并没有效果！

  ![image-20220416155120321](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161551378.png)

  进行bug诊断：

  我们发现点击禁用后发送的ajax请求json数据为：

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161554363.png)

  **请求的id错误了！！！失精了**

  首先查看我们对页面响应的数据是否是错误的：我们给页面响应的这个id是和数据库中的id是一致的，因此不是我们给前端响应的数据出错了

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161559543.png)

  同时我们也发现：前端请求我们后端的数据id也是出错误之后的

  ![image-20220416160428666](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161657687.png)

  所以这就说得通了，为什么数据没有改变，因为我们是根据id修改，而id不一样是无法进行修改的，为什么id会不一样呢？

  分页查询时候服务端响应给页面的数据id的值为19位数字，类型为long类型，**页面中js处理long类型数字只能精确到前16位**，上一最终通过ajax请求交给服务端的时候id就变了

  前面我们发现了问题，即js对long类型数据进行处理时丢失精度，导致提交的id和数据库中的id不一致

  如何解决这个问题？

  **我们可以在服务端给页面响应json数据时进行处理，将long类型的数据统一转换为String字符串**

  下面进行代码修复

- 代码修复

  具体实现：

  1. 提供对象转换器JacksonObjectMapper，基于Jackson进行java对象到json数据转换

     ```java
     package com.reggie.common;
     
     import com.fasterxml.jackson.databind.DeserializationFeature;
     import com.fasterxml.jackson.databind.ObjectMapper;
     import com.fasterxml.jackson.databind.module.SimpleModule;
     import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
     import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
     import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
     import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
     import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
     import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
     import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
     import java.math.BigInteger;
     import java.time.LocalDate;
     import java.time.LocalDateTime;
     import java.time.LocalTime;
     import java.time.format.DateTimeFormatter;
     import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
     
     /**
      * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
      * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
      * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
      */
     public class JacksonObjectMapper extends ObjectMapper {
     
         public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
         public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
         public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
     
         public JacksonObjectMapper() {
             super();
             //收到未知属性时不报异常
             this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
     
             //反序列化时，属性不存在的兼容处理
             this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
     
     
             SimpleModule simpleModule = new SimpleModule()
                     .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                     .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                     .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
     
                     .addSerializer(BigInteger.class, ToStringSerializer.instance)
                     .addSerializer(Long.class, ToStringSerializer.instance)//long类型进行序列化
                     .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                     .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                     .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
     
             //注册功能模块 例如，可以添加自定义序列化器和反序列化器
             this.registerModule(simpleModule);
         }
     }
     
     ```

     

  2. 在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转化器进行java对象到json数据的转换(如果我们不配置，其实我们使用的是Spring Mvc默认的消息转换器，现在我们来扩展它)

     ```java
     package com.reggie.config;
     
     import com.reggie.common.JacksonObjectMapper;
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.context.annotation.Configuration;
     import org.springframework.http.converter.HttpMessageConverter;
     import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
     import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
     import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
     
     import java.util.List;
     
     /**
      * mvc静态资源映射 配置类
      */
     
     @Slf4j
     @Configuration//说明这个是SpringBoot的配置类
     //让这个类继承WebMvcConfigurationSupport
     public class WebMvcConfig extends WebMvcConfigurationSupport {
         
         /**
          * 扩展Mvc框架的消息转换器
          * @param converters
          */
         @Override
         protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
             log.info("扩展消息转换器...");
             //创建消息转换器对象，作用：
             //将我们controller作用返回结果把它转成相应的json
             MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
             //设置对象转换器，底层使用Jackson将Java对象转为json
             messageConverter.setObjectMapper(new JacksonObjectMapper());
             //将上面的消息转换器对象追加到mvc框架的转换器集合中
             converters.add(0,messageConverter);//需要把我们的转换器放到最前面：下标是0，优先使用
     
         }
     }
     
     ```

     之后我们启动项目，发现：id和其他配置过的都变为了配置后的样子了，就已经发挥作用了

     ![image-20220416164340497](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204161643569.png)






### 2.6、编辑员工信息

- 需求分析

  在员工管理页面点击编辑按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最后点击保存按钮完成操作

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171446033.png)

  

- 代码开发

  1. 点击编辑按钮时，页面跳转到add.html,并且在地址栏中携带参数【员工id】

  2. 在add.html中获取url参数中的参数【员工id】

  3. 发送ajax请求，请求服务端，同时提交员工的id参数

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171453357.png)

     

  4. 服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面

     ```java
      /**
          * 根据id查询员工信息
          * 使用路径变量获取id
          * @param id
          * @return
          */
         @GetMapping("/{id}")
         public R<Employee> getById(@PathVariable Long id){
             log.info("根据id查询员工信息，获取到的id为{}",id);
             Employee employee = employeeService.getById(id);
             //如果查出来的employee是空，返回错误信息
             if (Objects.isNull(employee)){
                 return R.error("没有查询到对应的一个信息");
             }
             return R.success(employee);
         }
     ```

     

  5. 页面接收服务端响应的json数据，并通过VUE的数据绑定进行员工信息回显

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171520454.png)

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171521664.png)

     

  6. 点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端

  7. 服务端接收员工信息，进行处理，完成后给页面响应

  8. 页面接收响应信息进行响应的处理

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171524779.png)

     

     当我们点击了保存的时候它请求的是一个通用的update方法，和添加员工的接口是一样的，所以我们不需要在编写修改接口了！

     

- 功能测试







## 3、Day3业务开发-分类管理

### 3.1、公共字段自动填充

- 问题分析

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171538117.png)

  

  前面我们开发的代码中存在一些问题，比如说我们要手动设置创建时间、更新时间、创建人、更新人，而并不是我们只有一张表中有这些字段，而是很多表中都有这些字段，因此我们可以使用mybatis-plus提供的**公共字段自动填充**功能

- 代码实现

  实现步骤：

  1. 在实体类的属性上加入@TableField(表字段)注解，指定自动填充的策略

     ```java
     package com.reggie.entity;
     
     import com.baomidou.mybatisplus.annotation.FieldFill;
     import com.baomidou.mybatisplus.annotation.TableField;
     import lombok.Data;
     import java.io.Serializable;
     import java.time.LocalDateTime;
     
     /**
      * 员工实体类
      */
     @Data
     public class Employee implements Serializable {
     
         private static final long serialVersionUID = 1L;
     
         private Long id;
     
         private String username;
     
         private String name;
     
         private String password;
     
         private String phone;
     
         private String sex;
     
         //身份证号码，不过在数据库中的名称是id_number，
         // 但是我们在application.yml配置文件中开启了按照驼峰命名法映射，
         // 所以以后在配置yml的时候一定记得要开启这个配置
         private String idNumber;
     
         private Integer status;
     
         @TableField(fill = FieldFill.INSERT)//插入时填充字段
         private LocalDateTime createTime;
     
         @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
         private LocalDateTime updateTime;
     
         @TableField(fill = FieldFill.INSERT)//插入时填充字段
         private Long createUser;
     
         @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
         private Long updateUser;
     
     }
     
     ```

     

  2. 按照框架要求编写数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口

     ```java
     package com.reggie.common;
     
     import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
     import lombok.extern.slf4j.Slf4j;
     import org.apache.ibatis.reflection.MetaObject;
     import org.springframework.stereotype.Component;
     
     /**
      * 自定义元数据对象处理器
      */
     @Component//加入到spring容器中
     @Slf4j
     public class MyMetaObjectHandler implements MetaObjectHandler {
         /**
          * 当前端提交过来例如保存请求的时候
          * 在执行sql前会来到这个类中，对字段进行填充
          * 参数：metaObject:元数据，封装了数据对象（employee对象）
          * @param metaObject
          */
         @Override
         public void insertFill(MetaObject metaObject) {
             log.info("公共字段自动填充[insert]...");
             log.info(metaObject.toString());
             
     
         }
     
         @Override
         public void updateFill(MetaObject metaObject) {
             log.info("公共字段自动填充[update]...");
             log.info(metaObject.toString());
     
         }
     }
     
     ```

     

- 功能测试

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171600262.png)

  

- 功能完善

  首先先注释掉controller中的手动添加公共字段

  ```java
  //============MP公共字段自动填充==============
          //这个地方我们使用MP的字段自动填充功能：首先在实体类需要自动填充的属性上
          // 添加@TableField(fill = FieldFill.INSERT/FieldFill.INSERT_UPDATE )
          //然后再common包下创建数据对象处理器MyMetaObjectHandler并且实现MetaObjectHandler接口
          //实现insertFill和updateFill方法，在方法中实现需要填充的内容，这样就可以实现每次自动填充公共字段了！！！
  
          //设置创建和修改时间
  //        employee.setCreateTime(LocalDateTime.now());
  //        employee.setUpdateTime(LocalDateTime.now());
  
          //设置创建该用户的人
              //获得当前登陆用户的id
  //        HttpSession session = request.getSession();
  //        Long empId = (Long) session.getAttribute("employee");
  //        employee.setCreateUser(empId);
  //        employee.setUpdateUser(empId);
  //========MP公共字段自动填充===========
  ```

  在数据对象处理器中编写代码实现

  ```java
  package com.reggie.common;
  
  import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
  import lombok.extern.slf4j.Slf4j;
  import org.apache.ibatis.reflection.MetaObject;
  import org.springframework.stereotype.Component;
  
  import java.time.LocalDateTime;
  
  /**
   * 自定义元数据对象处理器
   */
  @Component//加入到spring容器中
  @Slf4j
  public class MyMetaObjectHandler implements MetaObjectHandler {
      /**
       * 插入字段自动填充
       * 当前端提交过来例如保存请求的时候
       * 在执行sql前会来到这个类中，对字段进行填充
       * 参数：metaObject:元数据，封装了数据对象（employee对象）
       * @param metaObject
       */
      @Override
      public void insertFill(MetaObject metaObject) {
          log.info("公共字段自动填充[insert]...");
          log.info(metaObject.toString());
          //设置自动填充值
              //创建更新时间
          metaObject.setValue("createTime", LocalDateTime.now());
          metaObject.setValue("updateTime", LocalDateTime.now());
              //创建更新人，因为我们需要从session中获取到当前登陆的用户，但是现在获取不到，我们先写死
          metaObject.setValue("createUser", 1L);
          metaObject.setValue("updateUser", 1L);
  
  
  
      }
  
      /**
       * 更新字段自动填充
       * @param metaObject
       */
      @Override
      public void updateFill(MetaObject metaObject) {
          log.info("公共字段自动填充[update]...");
          log.info(metaObject.toString());
          //在更新字段的时候我们就不需要再对创建字段进行修改了
        	metaObject.setValue("updateTime", LocalDateTime.now());
          metaObject.setValue("updateUser", 1L);
  
      }
  }
  
  ```

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171624210.png)

- 功能改进（修复bug）

  前面我们把createUser和updateUser设置了固定的值，现在我们需要改造成动态获取当前登陆用户的id，注意在MyMetaObjectHandler类中是不能获得HttpServletRequest中的HttpSession对象的，所以我们需要通过其他方法来获取登陆用户的id

  可以使用**ThreadLocal**来解决此问题，它是JDK中提供的一个类

  来来来：

  在学习ThreadLocal之前，我们需要先确认一件事情：那就是客户端每次发送的http请求，对应的在服务器端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程：

  1. LoginCheckFilter的doFilter方法
  2. EmployeeController的update方法
  3. MyMetaObjectHandler的updateFill方法

  可以在上面的三个方法中分别加入下面代码（获取当前线程的id）：

  ```java
  long id = Thread.currentThread().getId();
  log.info("线程id{}",id);
  ```

  执行编辑员工功能进行验证如下：

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171646628.png)

  通过观察控制台输出发现：一次请求对应的线程id是相同的

  什么是ThreadLocal？

  ThreadLocal并不是一个Thread，而是Thread的局部变量。当我们使用ThreadLocal维护变量的时候，ThreadLocal为每个使用该变量的线程提供一个独立的**变量副本**，所以每一个线程都可以独立地改变自己的副本，而且不会影响其他线程所对应的副本。Thread为每一个线程提供单独一份的存储空间，具有线程隔离的效果，只有在当前线程内才能获取到对应的值，线程外则不能访问。

  ThreadLocal常用方法：

  - public void set(T value)  设置当前线程的线程局部变量的值
  - public T get()                    返回当前线程所对应的线程局部变量的值

  因此：我们可以在用户登陆过滤器中LoginCheckfilter的doFilter方法中获取当前登陆用户的id，并调用ThreadLocal的set方法来设置当前线程的局部变量的值（用户的id），然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法获得当前线程对应的线程局部变量的值（用户id）

  实现步骤：

  1. 编写BaseContext工具类，基于ThreadLocal封装的工具类

     ```java
     package com.reggie.common;
     
     /**
      * 基于ThreadLocal封装的工具类，用于保存和获取当前登陆用户的id
      * 以线程为作用域，不用担心保存的副本弄混淆了（具有隔离性）
      */
     public class BaseContext {
         private static final ThreadLocal<Long> threadLocal = new InheritableThreadLocal<>();
     
         /**
          * 设置当前的id，拷贝到当前线程的副本中，方便以后取出
          * @param id
          */
         public static void setCurrentId(Long id){
             threadLocal.set(id);
         }
     
         /**
          * 获取值
          * @return
          */
         public static Long getCurrentId(){
             return threadLocal.get();
         }
     }
     
     ```

  2. 在LoginCheckFilter的doFilter方法中调用BaseContext来设置当前登陆用户的id

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171728478.png)

  3. 在MyMetaObjectHandler的方法中调用BaseContext获取登陆用户的id

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171729032.png)

     测试添加用户：

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204171732450.png)

     完美解决

     



### 3.2、新增分类

- 需求分析

  后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类。当我们在后台中添加菜品时，需要选择一个菜品分类；当我们在后台系统中添加一个套餐时，需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐

  ![image-20220418165927736](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181659778.png)

  ![image-20220418165957566](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181659598.png)

  

- 数据模型

  ![image-20220418170550367](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181705448.png)

  需要注意的是name是唯一的

- 代码开发

  - 实体类Category

    ```java
    package com.reggie.entity;
    
    import com.baomidou.mybatisplus.annotation.FieldFill;
    import com.baomidou.mybatisplus.annotation.IdType;
    import com.baomidou.mybatisplus.annotation.TableField;
    import com.baomidou.mybatisplus.annotation.TableId;
    import lombok.Data;
    import lombok.Getter;
    import lombok.Setter;
    import java.io.Serializable;
    import java.time.LocalDateTime;
    
    /**
     * 分类
     */
    @Data
    public class Category implements Serializable {
    
        private static final long serialVersionUID = 1L;
    
        private Long id;
    
    
        //类型 1 菜品分类 2 套餐分类
        private Integer type;
    
    
        //分类名称
        private String name;
    
    
        //顺序
        private Integer sort;
    
    
        //创建时间
        @TableField(fill = FieldFill.INSERT)
        private LocalDateTime createTime;
    
    
        //更新时间
        @TableField(fill = FieldFill.INSERT_UPDATE)
        private LocalDateTime updateTime;
    
    
        //创建人
        @TableField(fill = FieldFill.INSERT)
        private Long createUser;
    
    
        //修改人
        @TableField(fill = FieldFill.INSERT_UPDATE)
        private Long updateUser;
    
    
        //是否删除
    //    private Integer isDeleted;
    
    }
    
    ```

    

  - Mapper接口CategoryMapper

    ```java
    package com.reggie.mapper;
    
    import com.baomidou.mybatisplus.core.mapper.BaseMapper;
    import com.reggie.entity.Category;
    import org.apache.ibatis.annotations.Mapper;
    
    @Mapper
    public interface CategoryMapper extends BaseMapper<Category> {
    }
    
    ```

    

  - 业务层接口CategoryService

    ```java
    package com.reggie.service;
    
    import com.baomidou.mybatisplus.extension.service.IService;
    import com.reggie.entity.Category;
    
    public interface CategoryService extends IService<Category> {
    }
    
    ```

    

  - 业务层实现类CategoryServiceImpl

    ```java
    package com.reggie.service.impl;
    
    import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
    import com.reggie.entity.Category;
    import com.reggie.mapper.CategoryMapper;
    import com.reggie.service.CategoryService;
    import org.springframework.stereotype.Service;
    
    @Service
    public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
    }
    
    ```

    

  - 控制层CategoryController

    ```java
    package com.reggie.controller;
    
    import com.reggie.service.CategoryService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    
    /**
     * 分类管理
     */
    @RestController
    @RequestMapping("/category")
    public class CategoryController {
        @Autowired
        private CategoryService categoryService;
    
    }
    
    ```

  - 梳理开发流程

    - 页面发送ajax请求

      请求：POST请求（新增菜品和新增套餐都是请求的同一个接口，通过type的值来区分的），并且发送了json数据

      ![image-20220418172028095](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181720131.png)

      ![image-20220418172053880](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181720925.png)

      ![image-20220418172300308](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181723354.png)

    - 服务端Controller接收页面提交的数据并调用Service将数据进行保存

    - Service调用Mapper操作数据库，保存数据

      ```java
      package com.reggie.controller;
      
      import com.reggie.common.R;
      import com.reggie.entity.Category;
      import com.reggie.service.CategoryService;
      import lombok.extern.slf4j.Slf4j;
      import org.springframework.beans.factory.annotation.Autowired;
      import org.springframework.web.bind.annotation.PostMapping;
      import org.springframework.web.bind.annotation.RequestBody;
      import org.springframework.web.bind.annotation.RequestMapping;
      import org.springframework.web.bind.annotation.RestController;
      
      /**
       * 分类管理
       */
      @Slf4j
      @RestController
      @RequestMapping("/category")
      public class CategoryController {
          @Autowired
          private CategoryService categoryService;
      
          /**
           * 新增分类
           * @param category
           * @return
           */
          @PostMapping
          public R<String> save(@RequestBody Category category){
              log.info("Category:{}",category);
              categoryService.save(category);
              return R.success("新增分类成功");
          }
      
      }
      
      ```

      

- 功能测试





### 3.3、分类信息分页查询

- 需求分析

  系统中的分类很多的时候，如果在一个页面中全部展示出来会显得很乱，不便于查看，所以我们需要使用分页的方式来展示页表数据

- 代码开发

  1. 页面方式ajax请求，将我们分页查询参数（page，pageSize）提交到数据库

     ![image-20220418174758709](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204181747765.png)

     

  2. 服务端Controller接收页面提交的数据并调用Service查询数据

  3. Service调用Mapper操作数据库，查询分页数据

  4. Controller将查询到的分页数据响应给页面

  5. 页面接收到分页数据通过ElementUI的Table组件展示到页面上

     ```java
     /**
          * 分页查询
          * @param page
          * @param pageSize
          * @return
          */
         @GetMapping("/page")
         public R<Page> page(int page,int pageSize){
             //分页构造器
             Page<Category> pageInfo = new Page<>(page,pageSize);
             //条件过滤器（排序）
             LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
             //添加排序条件，根据sort进行排序
             queryWrapper.orderByAsc(Category::getSort);
             //进行分页查询
             categoryService.page(pageInfo,queryWrapper);
     
             return R.success(pageInfo);
         }
     
     ```

     

- 功能测试



### 3.4、删除分类

- 需求分析

  在我们分类管理列表页面上可以对某个分类进行删除操作。需要注意的是**当分类关联了菜品或者套餐时，此分类不允许删除**

  ![image-20220419112604931](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204191126965.png)

  

- 代码开发

  1. 页面发送ajax请求，将参数ids提交到服务端

     ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204191128688.png)

     

  2. 服务端controller接收页面提交的数据并调用service删除数据

  3. service调用mapper操作数据库

     ```java
     /**
          * 根据id删除分类
          * @param ids
          * @return
          */
         @DeleteMapping
         public R<String> deleteById(Long ids){
             log.info("删除的ids为{}",ids);
             
             categoryService.removeById(ids);
             return R.success("删除成功!");
         }
     ```

     

- 功能测试

  删除成功

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204191134670.png)

  

- 功能完善

  前面我们已经实现了根据ids删除分类的功能，但是并没有检查删除的分类是否关联了菜品或者套餐，所以我们需要进行功能完善

  要完善分类删除功能，需要先准备基础的类和接口：

  1. 实体类Dish和Setmeal

     ```java
     package com.reggie.entity;
     
     import com.baomidou.mybatisplus.annotation.FieldFill;
     import com.baomidou.mybatisplus.annotation.IdType;
     import com.baomidou.mybatisplus.annotation.TableField;
     import com.baomidou.mybatisplus.annotation.TableId;
     import lombok.Data;
     import java.io.Serializable;
     import java.math.BigDecimal;
     import java.time.LocalDateTime;
     
     /**
      菜品
      */
     @Data
     public class Dish implements Serializable {
     
         private static final long serialVersionUID = 1L;
     
         private Long id;
     
     
         //菜品名称
         private String name;
     
     
         //菜品分类id
         private Long categoryId;
     
     
         //菜品价格
         private BigDecimal price;
     
     
         //商品码
         private String code;
     
     
         //图片
         private String image;
     
     
         //描述信息
         private String description;
     
     
         //0 停售 1 起售
         private Integer status;
     
     
         //顺序
         private Integer sort;
     
     
         @TableField(fill = FieldFill.INSERT)
         private LocalDateTime createTime;
     
     
         @TableField(fill = FieldFill.INSERT_UPDATE)
         private LocalDateTime updateTime;
     
     
         @TableField(fill = FieldFill.INSERT)
         private Long createUser;
     
     
         @TableField(fill = FieldFill.INSERT_UPDATE)
         private Long updateUser;
     
     
         //是否删除
         private Integer isDeleted;
     
     }
     
     ```

     ```java
     package com.reggie.entity;
     
     import com.baomidou.mybatisplus.annotation.FieldFill;
     import com.baomidou.mybatisplus.annotation.IdType;
     import com.baomidou.mybatisplus.annotation.TableField;
     import com.baomidou.mybatisplus.annotation.TableId;
     import lombok.Data;
     import java.io.Serializable;
     import java.math.BigDecimal;
     import java.time.LocalDateTime;
     
     /**
      * 套餐
      */
     @Data
     public class Setmeal implements Serializable {
     
         private static final long serialVersionUID = 1L;
     
         private Long id;
     
     
         //分类id
         private Long categoryId;
     
     
         //套餐名称
         private String name;
     
     
         //套餐价格
         private BigDecimal price;
     
     
         //状态 0:停用 1:启用
         private Integer status;
     
     
         //编码
         private String code;
     
     
         //描述信息
         private String description;
     
     
         //图片
         private String image;
     
     
         @TableField(fill = FieldFill.INSERT)
         private LocalDateTime createTime;
     
     
         @TableField(fill = FieldFill.INSERT_UPDATE)
         private LocalDateTime updateTime;
     
     
         @TableField(fill = FieldFill.INSERT)
         private Long createUser;
     
     
         @TableField(fill = FieldFill.INSERT_UPDATE)
         private Long updateUser;
     
     
         //是否删除
         private Integer isDeleted;
     }
     
     ```

     

  2. Mapper接口和DishMapper和SetmealMapper

     ```java
     package com.reggie.mapper;
     
     import com.baomidou.mybatisplus.core.mapper.BaseMapper;
     import com.reggie.entity.Dish;
     import org.apache.ibatis.annotations.Mapper;
     
     /**
      * 菜品的mapper
      */
     @Mapper
     public interface DishMapper extends BaseMapper<Dish> {
     }
     
     ```

     ```java
     package com.reggie.mapper;
     
     import com.baomidou.mybatisplus.core.mapper.BaseMapper;
     import com.reggie.entity.Setmeal;
     import org.apache.ibatis.annotations.Mapper;
     
     /**
      * 套餐的mapper
      */
     @Mapper
     public interface SetmealMapper extends BaseMapper<Setmeal> {
     }
     
     ```

     

  3. Service接口DishService和SetmealService

     ```java
     package com.reggie.service;
     
     import com.baomidou.mybatisplus.extension.service.IService;
     import com.reggie.entity.Dish;
     
     public interface DishService extends IService<Dish> {
     }
     
     ```

     ```java
     package com.reggie.service;
     
     import com.baomidou.mybatisplus.extension.service.IService;
     import com.reggie.entity.Setmeal;
     
     public interface SetmealService extends IService<Setmeal> {
     }
     
     ```

     

  4. Service实现类DishServiceImpl和SetmealServiceImpl

     ```java
     package com.reggie.service.impl;
     
     import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
     import com.reggie.entity.Dish;
     import com.reggie.mapper.DishMapper;
     import com.reggie.service.DishService;
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.stereotype.Service;
     
     @Service
     @Slf4j
     public class DishServiceImpl extends ServiceImpl<DishMapper, Dish> implements DishService {
     }
     
     ```

     ```java
     package com.reggie.service.impl;
     
     import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
     import com.reggie.entity.Setmeal;
     import com.reggie.mapper.SetmealMapper;
     import com.reggie.service.SetmealService;
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.stereotype.Service;
     
     @Service
     @Slf4j
     public class SetmealServiceImpl extends ServiceImpl<SetmealMapper, Setmeal> implements SetmealService {
     }
     
     ```

  5. 在CategoryService中自定义业务逻辑方法

     ```java
     package com.reggie.service;
     
     import com.baomidou.mybatisplus.extension.service.IService;
     import com.reggie.entity.Category;
     
     public interface CategoryService extends IService<Category> {
         void remove(Long id);
     }
     
     ```

  6. 在CategoryServiceImpl中实现

     ```java
     package com.reggie.service.impl;
     
     import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
     import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
     import com.reggie.entity.Category;
     import com.reggie.entity.Dish;
     import com.reggie.entity.Setmeal;
     import com.reggie.mapper.CategoryMapper;
     import com.reggie.service.CategoryService;
     import com.reggie.service.DishService;
     import com.reggie.service.SetmealService;
     import org.springframework.beans.factory.annotation.Autowired;
     import org.springframework.stereotype.Service;
     
     @Service
     public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
     
         @Autowired
         private DishService dishService;
         @Autowired
         private SetmealService setmealService;
         /**
          * 根据id删除分类（在删除前进行判断，是否关联了套餐或菜品）
          * @param id
          */
         @Override
         public void remove(Long id) {
             LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();
             //添加查询条件，根据分类id进行查询
             dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);
     
             int count1 = dishService.count(dishLambdaQueryWrapper);
     
             //查询当前分类是否关联了菜品，如果已经关联，我们就抛出一个业务异常
             if (count1 > 0){
                 //已经关联了菜品，抛出业务异常
                 throw new CustomException("当前分类下关联了套餐，不能删除");
     
     
             }
     
             LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
             //添加查询条件，根据分类id进行查询
             setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);
     
             int count2 = setmealService.count(setmealLambdaQueryWrapper);
     
             //查询当前分类是否关联了套餐，如果已经关联，我们就抛出一个业务异常
             if (count2 > 0){
                 //已经关联了套餐，抛出业务异常
     	          throw new CustomException("当前分类下关联了菜品，不能删除");
     
             }
     
             //既没有关联菜品又没有关联套餐
             //可以正常删除分类
             super.removeById(id);
     
         }
     }
     
     ```

  7. 自定义异常类

     ```java
     package com.reggie.common;
     
     /**
      * 自定义业务异常
      */
     public class CustomException extends RuntimeException{
         public CustomException(String message){
             super(message);
         }
     }
     
     ```

  8. 全局异常处理器中添加自定义的异常处理器，向页面返回信息

     ```java
     package com.reggie.common;
     
     import lombok.extern.slf4j.Slf4j;
     import org.springframework.stereotype.Controller;
     import org.springframework.web.bind.annotation.ControllerAdvice;
     import org.springframework.web.bind.annotation.ExceptionHandler;
     import org.springframework.web.bind.annotation.ResponseBody;
     import org.springframework.web.bind.annotation.RestController;
     
     import java.sql.SQLIntegrityConstraintViolationException;
     
     /**
      * 全局异常处理器
      * 代理AOP
      */
     //不管哪个类上加了这个RestController或者Controller注解，都会被我们这个类处理
     @ControllerAdvice(annotations = {RestController.class, Controller.class})
     @ResponseBody//因为我们还要写一个方法，最终返回json数据的
     @Slf4j
     public class GlobalExceptionHandler {
     
         //......
     
         /**
          * 异常处理方法：自定义异常，删除分类判断是否有菜品或者套餐
          * @param ex
          * @return
          */
         @ExceptionHandler(CustomException.class)
         public R<String> exceptionHandler(CustomException ex){
             log.error(ex.getMessage());
     
             return R.error(ex.getMessage());
         }
     
     }
     
     ```

     



### 3.5、修改分类

- 需求分析

  在分类管理列表页面我们可以点击修改按钮，就弹出修改窗口，我们可以进行修改，最后点击确定按钮完成修改操作

  ![image-20220421143939172](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204211439241.png)

  回显数据前端已经使用vue动态绑定帮我们完成了，我们只需要处理当用户点击确定按钮后的这次请求就可以了

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204211441017.png)

  ![](https://xiaohualiyuntuchuang.oss-cn-hangzhou.aliyuncs.com/img/202204211442449.png)

- 代码开发

  ```java
  /**
       * 根据id修改分类信息
       * @param category
       * @return
       */
      @PutMapping
      public R<String> updateById(@RequestBody Category category){
          log.info("修改分类信息:{}",category);
  
          categoryService.updateById(category);
          return R.success("修改分类信息成功!");
      }
  ```

- 功能测试





## 4、Day4业务开发-菜品管理

### 4.1、文件上传下载

- 文件上传介绍

  文件上传，也称为upload，是指将本地图片、视频、音频、等文件、上传到服务器上，可以供其他用户浏览下载的过程。

  文件上传时，对页面的form表单的要求：

  - method = "post"		采用post方式提交数据
  - enctype = "multipart/form-data"     采用multipart格式上传文件
  - type = "file"             使用input的file控件上传

  举例：

  ```html
  <form method="post" action="/common/upload" enctype="multipart/form-data">
          <input name="myFile" type="file">
          <input type="submit" value="提交">
      </form>
  ```

  目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传。

  例如ElementUI中提供的upload上传组件

  服务端要接收客户端页面上传的文件，通常会使用Apache的两个组件：

  - commons-fileupload
  - common-io

  Spring框架在spring-web包中对文件上传进行了封装，大大简化了我们服务端代码的开发，我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如：

  ```java
  /**
  *文件上传
  */
  @PostMapping("/upload")
  public R<String> upload(MultipartFile file){
    System.out.println(file);
    return null;
  }
  ```

- 文件下载介绍

  文件下载也称为download，是指将文件从服务器传输到本地计算机的过程

  通过浏览器进行文件下载，通常有两种表现形式：

  - 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录
  - 直接在浏览器中打开

  通过浏览器进行文件下载，**本质上就是服务端将文件以流的形式写回到浏览器的过程**

- 文件上传，页面可以使用ElementUI提供上传组件

  
  
  



